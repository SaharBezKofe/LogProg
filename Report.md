# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### Студент: Уваров А.П.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5-       |

>

## Введение

> В результате выполнения курсового проекта я получу навыки функционального и логического программирования, изучу язык программирования Prolog, улучшу своё логическое мышления, начну поверхностное изучения языка программирования Python, познакомлюсь с типом файлов .ged.
Грамматика в 5
## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска тещи
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Я скачал программу "MyHeritage Family Tree Builder", создал в нем свою родословную, потом экспортировал все в формате .ged.

## Конвертация родословного дерева (Вариант 2)

Изначально я решил использовать Prolog, однако, в интернете было тяжело найти нужную информацию. В свое время работал с текстом в языках программирования C#, C++, C - решил, что было бы неплохо опробовать новый язык для меня - Python, к тому же преподаватель сам советовал этот язык. В итоге я использовал Python впервые и эта задача мне далась в разы легче, чем с языком программирования Prolog.
Принцип действия программы:
```diff
 1. Открывал 2 файла или их создавал - один файл в формате .ged, другой .pl.
 2. Реализовал цикл(for line in f:), который перебирает весь файл .ged построчно.
 3. Проверял если в строке на первой и третьей позициях цифра '2' и буква 'G' (if line[0] == '2' and line[2] == 'G':), то это имя - записывал в словарь.
 4. Проверял если в строке на первой и третьей позициях цифра '2' и буква 'S' (elif line[0] == '2' and line[2] == 'S':), то это фамилия - добавлял символ '_' и фамилию в словарь.
 5. Проверял если в строке на 3 и 4 позициях символы 'S' и 'E' (elif line[2] == 'S' and line[3] == 'E':), то это пол - записывал в другой уже словарь.
 6. Проверял айди семьи (elif line[2] == 'F' and line[5] == 'S':), к которой принадлежит человек и добавлял айди в соответствующий словарь.
 7. Проверял айди семьи к которой выбранный человек является ребенком (elif line[2] == 'F' and line[5] == 'C':), потом добавлял айди в соответствующий словарь.
 8. Выводил количество элементов в словарях и сами элементы для проверки правильности выполнения.
 9. С помощью цикла (for i in range(len(names)):) прошел по всем найденным именам, собрал для каждого имени нужные данные и создал конечный факт типа (parent(parent,child)) и добавил созданный факт в переменную,в другую переменную добавил факт пола выбранного человека (sex(parent,m/f)).
 10. Записываю в файл выхода (.pl) первую переменную, содержащую все факты parent(), потом вторую, содержащую все факты sex().
 11. Закрываю два файла.
```

## Предикат поиска родственника (Вариант 6)

Принцип работы алгоритма поиска тещи:
```diff
 1. Определяю, что входной человек является мужчиной.
 2. Ищу ребенка для входного человека.
 3. Ищу родителя для ребенка входного человека.
 4. Проверяю, что родитель женщина, то есть нахожу жену входного человека.
 5. Ищу родителей жены.
 6. Проверяю, что родитель женщина, то есть нахожу тещу входного человека.
```

```diff
findmotherlaw(X,Y) :-
    sex(X,m), 
    parent(X,Z),
    parent(X1,Z),
    sex(X1,f),
    parent(Y,X1),
    sex(Y,f).
```

Тесты:
```diff
1 ?- findmotherlaw(A,B).
A = ivan_trofenuk,
B = vera_kalugina ;
A = pavel_uvarov,
B = lubov_ushakova ;
A = alexandr_ushakov,
B = mariya_kojevnikova ;
A = vladimir_uvarov,
B = taisiya_chadina ;
false.

2 ?- findmotherlaw(pavel_uvarov,B).
B = lubov_ushakova ;
false.

3 ?- findmotherlaw(andrey_uvarov,B).
false.
```

## Определение степени родства

Я немного поменял вывод, не так, как требует того условие, но, как мне кажется, вывод стал интереснее.

Перегрузил предикат для 2 и 3 параметров.   
3 параметра применяются в нахождении братьев и сестер:
```prolog
relative(A,brother,B) :- 
    findall(T,(parent(Y,A),parent(Y,T),T\=A,sex(T,m)),B).
relative(A,sister,B) :- 
    findall(T,(parent(Y,A),parent(Y,T),T\=A,sex(T,f)),B).
```
Алгоритм очень простой, через findall находим всех братьев, проверяем, чтоб не равнялся исходному брату, после этого выводим.

2 параметра применяются для определения степени родства между двумя людьми:
```prolog
relative(A,A) :- !,write("Один и тот же человек!"),nl.
relative(A,B) :-
    findall([R],go(A,[],R),Z),appendAll(Z,A,I),
    move(I,B),
    write("Для "),write(A),nl.
```
Алгоритм работы немного усложнился, применяется поиск в ширину, на начальном этапе мы находим основные пути движения от исходного человека,
проверяются на существование дети и родители, потом компануется все в один список списков и посылается в предикат move, который в свою очередь отвечает за нахождение новых путей:
```prolog
move([[U,U2|T]|_],U) :- !,
    write(U),nl,   
    writerOne([U,U2]),writer([U2|T]).

move([[H|T]|Tail],U) :-
    findall([R],go(H,T,R),L),appendAll(L,H,D),
    mergeLists(D,T,Res),
    append(Tail,Res,Tmp),
    move(Tmp,U).
```
В данном предикате проверяется нахождение нашего второго человека, который мы ввели изначально, в предикате он под параметром - U. Если не совпадает, то тогда находим все возможные передвижения, а также, чтоб не повторялись в пути, а дальше сцепляем список с хвостом очереди и вызываем снова рекурсивно предикат move.

## Естественно-языковый интерфейс
```prolog
start(In) :-
    In = [Is,Name,Rel,Name2],
    wordIs(Is),
    wordBrother(Rel) -> % brother
    (wordHisHer(Name) -> nb_getval(name, Value), parent(Y,Value),sex(Y,m),parent(Y,Name2),sex(Name2,m),!; In = [_,Name,_,Name2],parent(Y,Name),sex(Y,m),parent(Y,Name2),sex(Name2,m),!)
    ;
    In = [Is,Name,Rel,Name2],
    wordIs(Is),
    wordSister(Rel) -> % sister
    (wordHisHer(Name) -> nb_getval(name, Value), parent(Y,Value),sex(Y,m),parent(Y,Name2),sex(Name2,f),!; In = [_,Name,_,Name2],parent(Y,Name),sex(Y,m),parent(Y,Name2),sex(Name2,f),!).
```
Предикат обработки преложений типа: is name(h*) brother/sister name   
Алгоритм - мы четко знаем количество слов, поэтому In можно разделить сразу на 4 слова, дальше проверяем вводимые слова, чтоб не было так, что в 1 слове предложения стоит не is,а who. Дальше проверяем brother/sister со структурой if than else. Если нам надо найти брата, то потом проверяем полное имя мы ввели или his,him,her так же конструкцией if than else. Дальше находим брата исходного имени, если было his,him, то берем имя из getval. Выводим true или false, обязательно используя отсечение, чтоб пользователю не надо было лишний раз вводить ;.

У меня есть 4 запроса:    
Who is brother/sister/motherlaw to name(h*)   
How many brothers/sisters does name(h*) have - int    
who is name(h*) mother/father   
is name(h*) brother/sister name? - true, false   
Все запросы реализуются через предикат start, толком никак не отличаются от выше описанного алгоритма.

## Вывод
Данный курсовой проект познакомил меня с языком программирования Пролог,а также чуть-чуть с Python. Пролог оказался для меня очень странным языком, в некоторых местах было очень просто, что, конечно же, выделяло этот язык от остальных мне знакомых. В других местах было очень сложно и непонятно, у меня были некоторые проблемы с append списков, иногда я неправильно понимал их структуру,используя | вместо , - что и приводило к долгим часам отладки и нервов. Однако, хочется сказать, что это первый логический язык в моей жизни, и мне он понравился, синстаксис языка не очень сложный, можно легко просмотреть за каждым движением программы, но нет нормальной документации и в целом информации на этот язык. Я задумался над тем, как может пролог или другой логический язык программирования использоваться в искусственном интеллекте, стало интересно, захотелось попробовать.
